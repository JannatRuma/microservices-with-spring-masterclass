# Microservices with Spring Boot and Spring Cloud (Masterclass)

Learn how to use Spring Boot to implement loosely-coupled, self-contained, resilient, secure, and scalable
applications. Youâ€™ll implement the main microservices patterns like API gateway, service discovery, load balancing,
and externalized configuration leveraging the power of Spring Cloud.

## Lab 1 - Building a microservice with Spring Boot

In this lab, you'll build a blocking microservice using Spring Boot. It will expose a REST API and persist data
in a PostgreSQL database.

### 1.1 Initializing a Spring Boot project

> **Assignment**. Initialize a new Spring Boot project for Book Service including the following dependencies:
> Spring Web, Spring Data JDBC, PostgreSQL Driver, Flyway Migration, Lombok. Then, configure application name
> and server port.

You can initialize a new Spring Boot project for **Book Service** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.5.1+
* _Name_: book-service
* _Packaging_: JAR
* _Java_: 11+

Choose the following dependencies:

* _Spring Web (`org.springframework.boot:spring-boot-starter-web`)_ provides the necessary libraries for building
  web applications with Spring MVC and includes Tomcat as the default embedded server.
* _Spring Data JDBC (`org.springframework.boot:spring-boot-starter-data-jdbc`)_ provides the necessary libraries
  to persist data in relational databases with JDBC using Spring Data in blocking applications.
* _PostgreSQL Driver (`org.postgresql:postgresql`)_ provides a JDBC driver that allows the application to connect
  to a PostgreSQL database.
* _Flyway Migration (`org.flywaydb:flyway-core`)_ provides the Flyway Java driver that allows the application
  to version control a database through migrations.
* _Lombok (`org.projectlombok:lombok`)_ is an annotation library that helps reducing boilerplate code. It's not
  required, but it'll help me showing you cleaner and more focused examples.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 8001

spring:
  application:
    name: book-service
```

### 1.2 Domain entities and repositories with Spring Data JDBC

> **Assignment**. Implement the domain classes for Book Service: `Book` and `BookRepository`.
> Then configure the integration of Spring Boot with a PostgreSQL instance and initialize the schema
> with a Flyway migration.

The Book Service application will let you manage books for a bookshop. First of all, create a new
`domain` package in the Book Service project. Then, define a `Book` class to model the domain entity.

```java
@Data
public class Book {

	@Id
	private Long id;
	private String isbn;
	private String title;

}
```

* `@Data` is a Lombok annotation to generate boilerplate code for the class, such as getters and setters.
* `@Id` is a Spring Data annotation to mark the identifier (primary key) of the domain entity.

Next, define a `BookRepository` interface to provide access to Book data from the database.

```java
public interface BookRepository extends CrudRepository<Book,Long> {
	Optional<Book> findByIsbn(String isbn);
	void deleteByIsbn(String isbn);
}
```

Then, configure a `DataSource` to integrate the application with a PostgreSQL instance.
In `src/main/resources/application.yml`, add the following configuration.

```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/bookdb
    username: admin
    password: admin
```

Finally, create a Flyway migration to initialize the schema for the `Book` domain entity.
Write the SQL query to initialize the schema in `src/main/resources/db/migration/V1__Initial_schema.sql`.

```sql
CREATE TABLE book (
    id                  BIGSERIAL PRIMARY KEY NOT NULL,
    isbn                varchar(255) UNIQUE NOT NULL,
    title               varchar(255) NOT NULL
);
```

### 1.3 Run PostgreSQL as a Docker container

> **Assignment**. Use Docker Compose to define and run a PostgreSQL container called `postgres-book`.

Create a `docker-compose.yml` file and define a service to run a PostgreSQL database for Book Service.

```yaml
version: "3.8"
services:
  postgres-book:
    image: "postgres:latest"
    container_name: "postgres-book"
    ports:
      - 5432:5432
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=admin
      - POSTGRES_DB=bookdb
```

Then, open a Terminal window, navigate to the folder where you Docker Compose file is located,
and run this command to run PostgreSQL.

```bash
$ docker-compose up -d postgres-book
```

### 1.4 RESTful microservices with Spring Web

> **Assignment**. Implement a `BookController` class to expose a REST API to create, read, and delete books.

| Endpoint	      | Method   | Req. body  | Status | Resp. body     | Description    		   	     |
|:---------------:|:--------:|:----------:|:------:|:--------------:|:-------------------------------|
| `/books`        | `GET`    |            | 200    | Iterable<Book> | Get all the books in the catalog. |
| `/books`        | `POST`   | Book       | 201    | Book           | Add a new book to the catalog. |
| `/books/{isbn}` | `GET`    |            | 200    | Book           | Get the book with the given ISBN. |
| `/books/{isbn}` | `DELETE` |            | 204    |                | Delete the book with the given ISBN. |

First, define a new `web` package. Then, create a `BookController` class inside with handlers for
GET, POST, and DELETE requests as described in the table above.

```java
@RestController
@RequestMapping("books")
@RequiredArgsConstructor
public class BookController {
	private final BookRepository bookRepository;

	@GetMapping
	public Iterable<Book> getAllBooks() {
		return bookRepository.findAll();
	}

	@GetMapping("{isbn}")
	public Optional<Book> getBookByIsbn(@PathVariable("isbn") String isbn) {
		return bookRepository.findByIsbn(isbn);
	}

	@PostMapping
	@ResponseStatus(HttpStatus.CREATED)
	public Book addBook(@RequestBody Book book) {
		return bookRepository.save(book);
	}

	@DeleteMapping("{isbn}")
	@ResponseStatus(HttpStatus.NO_CONTENT)
	public void delete(@PathVariable String isbn) {
		bookRepository.deleteByIsbn(isbn);
	}
}
```

The controller makes use of a few annotations:
* `@RestController` is a stereotype annotation marking a class as a Spring component and as a source of handlers
  for REST endpoints.
* `@RequestMapping` identifies the root path mapping URI for which the class provides handlers ("/books").
* `@GetMapping` maps HTTP GET requests onto the specific handler method.
* `@PostMapping` maps HTTP POST requests onto the specific handler method.
* `@DeleteMapping` maps HTTP DELETE requests onto the specific handler method.
* `@ResponseStatus` returns a specific HTTP status if the request is successful.
* `@PathVariable` binds a method parameter to a URI template variable ({isbn}).
* `@RequestBody` binds a method parameter to the body of a web request.
* `@RequiredArgsConstructor` generates a constructor with BookRepository, that gets autowired through construction
  injection.

### 1.5 Running a Spring Boot microservice

> **Assignment**. Run the Book Service application and test its behaviour.

Open a Terminal window, navigate to the root folder of the Book Service project,
and run the application with the command:

```bash
$ ./gradlew bootRun
```

You can test the application with curl or httpie.

```bash
$ http POST :8001/books isbn="1234567890" title="The Lord of the Rings"
```

```bash
$ http :8001/books"
```

```bash
$ http DELETE :8001/books/1234567890"
```
